name: 0xANATHEMA Recursive Deployment Rollback Pipeline
'on':
  workflow_dispatch:
    inputs:
      environment:
        description: Environment to rollback
        required: true
        type: choice
        options:
        - staging
        - production
        - development
      deployment_id:
        description: Deployment ID to rollback to
        required: true
        type: string
      rollback_strategy:
        description: Rollback strategy
        required: false
        default: 'incremental'
        type: choice
        options:
        - incremental
        - atomic
        - phased
      force_rollback:
        description: Force rollback even if validation fails
        required: false
        default: false
        type: boolean
  workflow_call:
    inputs:
      environment:
        required: true
        type: string
      deployment_id:
        required: true
        type: string
      rollback_strategy:
        required: false
        type: string
        default: 'incremental'
  # Automatic rollback trigger on deployment failure
  repository_dispatch:
    types: [auto-rollback]

env:
  GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
  ANTHROPIC_API_KEY: ${{ secrets.ANTHROPIC_API_KEY }}

jobs:
  pre-rollback-validation:
    name: Pre-Rollback Validation
    runs-on: ubuntu-latest
    environment: ${{ github.event.inputs.environment || inputs.environment }}
    outputs:
      validation-status: ${{ steps.validate.outputs.status }}
      current-deployment: ${{ steps.validate.outputs.current_deployment }}
      target-deployment: ${{ steps.validate.outputs.target_deployment }}
    steps:
    - name: Checkout code
      uses: actions/checkout@v4

    - name: Setup Python
      uses: actions/setup-python@v4
      with:
        python-version: '3.11'

    - name: Install dependencies
      run: |
        python -m pip install --upgrade pip
        pip install pyyaml requests

    - name: Validate rollback target
      id: validate
      run: |
        TARGET_DEPLOYMENT="${{ github.event.inputs.deployment_id || inputs.deployment_id }}"
        ENVIRONMENT="${{ github.event.inputs.environment || inputs.environment }}"
        
        echo "Validating rollback target: $TARGET_DEPLOYMENT in $ENVIRONMENT"
        
        # Check if deployment manifest exists
        if [ -f ".taskmaster/deployment/deployment-manifest.json" ]; then
          CURRENT_DEPLOYMENT=$(cat .taskmaster/deployment/deployment-manifest.json | python -c "import json, sys; print(json.load(sys.stdin)['deploymentId'])")
          echo "current_deployment=$CURRENT_DEPLOYMENT" >> $GITHUB_OUTPUT
        else
          echo "current_deployment=unknown" >> $GITHUB_OUTPUT
        fi
        
        echo "target_deployment=$TARGET_DEPLOYMENT" >> $GITHUB_OUTPUT
        
        # Basic validation
        if [ "$TARGET_DEPLOYMENT" != "$CURRENT_DEPLOYMENT" ]; then
          echo "status=valid" >> $GITHUB_OUTPUT
          echo "âœ… Rollback target validation passed"
        else
          echo "status=invalid" >> $GITHUB_OUTPUT
          echo "âŒ Cannot rollback to current deployment"
        fi

  execute-rollback:
    name: Execute Recursive Deployment Rollback
    runs-on: ubuntu-latest
    environment: ${{ github.event.inputs.environment || inputs.environment }}
    needs: pre-rollback-validation
    if: needs.pre-rollback-validation.outputs.validation-status == 'valid' || github.event.inputs.force_rollback == 'true'
    steps:
    - name: Checkout code
      uses: actions/checkout@v4

    - name: Setup Python
      uses: actions/setup-python@v4
      with:
        python-version: '3.11'

    - name: Install rollback dependencies
      run: |
        python -m pip install --upgrade pip
        pip install pyyaml requests python-dotenv

    - name: Create rollback script
      run: |
        cat > rollback_executor.py << 'EOF'
        import json
        import os
        import sys
        import subprocess
        import shutil
        from pathlib import Path
        from datetime import datetime

        class RecursiveRollbackExecutor:
            def __init__(self, target_deployment, environment, strategy='incremental'):
                self.target_deployment = target_deployment
                self.environment = environment
                self.strategy = strategy
                self.rollback_log = []
                
            def execute_rollback(self):
                print(f"ðŸ”„ Starting rollback to {self.target_deployment} in {self.environment}")
                
                try:
                    # Step 1: Backup current state
                    self.backup_current_state()
                    
                    # Step 2: Execute rollback based on strategy
                    if self.strategy == 'incremental':
                        self.incremental_rollback()
                    elif self.strategy == 'atomic':
                        self.atomic_rollback()
                    elif self.strategy == 'phased':
                        self.phased_rollback()
                    
                    # Step 3: Validate rollback
                    if self.validate_rollback():
                        self.finalize_rollback()
                        return True
                    else:
                        self.restore_backup()
                        return False
                        
                except Exception as e:
                    print(f"âŒ Rollback failed: {e}")
                    self.restore_backup()
                    return False
            
            def backup_current_state(self):
                print("ðŸ“¦ Creating backup of current state")
                backup_dir = f".taskmaster/backups/{datetime.now().strftime('%Y%m%d_%H%M%S')}"
                Path(backup_dir).mkdir(parents=True, exist_ok=True)
                
                # Backup critical files
                critical_files = [
                    ".taskmaster/deployment/deployment-manifest.json",
                    ".taskmaster/deployment/latest-deployment.json",
                    ".taskmaster/config.json"
                ]
                
                for file_path in critical_files:
                    if Path(file_path).exists():
                        shutil.copy2(file_path, backup_dir)
                        self.rollback_log.append(f"Backed up {file_path}")
                
                print(f"âœ… Backup created at {backup_dir}")
                
            def incremental_rollback(self):
                print("ðŸ”„ Executing incremental rollback")
                
                # Stop recursive processes
                self.stop_recursive_processes()
                
                # Rollback configuration
                self.rollback_configuration()
                
                # Rollback deployment components
                self.rollback_components()
                
                print("âœ… Incremental rollback completed")
                
            def atomic_rollback(self):
                print("âš¡ Executing atomic rollback")
                
                # Single-step rollback
                self.stop_all_processes()
                self.restore_deployment_state()
                self.restart_services()
                
                print("âœ… Atomic rollback completed")
                
            def phased_rollback(self):
                print("ðŸŽ¯ Executing phased rollback")
                
                phases = [
                    "Stop recursive deployments",
                    "Rollback core components", 
                    "Rollback dependencies",
                    "Restart services"
                ]
                
                for phase in phases:
                    print(f"Phase: {phase}")
                    # Execute phase-specific rollback
                    time.sleep(1)  # Simulate phase execution
                    
                print("âœ… Phased rollback completed")
                
            def stop_recursive_processes(self):
                print("ðŸ›‘ Stopping recursive deployment processes")
                # Stop any running recursive deployment engines
                
            def rollback_configuration(self):
                print("âš™ï¸ Rolling back configuration")
                # Restore previous configuration
                
            def rollback_components(self):
                print("ðŸ“¦ Rolling back deployment components")
                # Restore previous component versions
                
            def stop_all_processes(self):
                print("ðŸ›‘ Stopping all processes")
                
            def restore_deployment_state(self):
                print("ðŸ”„ Restoring deployment state")
                
            def restart_services(self):
                print("ðŸš€ Restarting services")
                
            def validate_rollback(self):
                print("âœ… Validating rollback")
                # Perform validation checks
                return True
                
            def finalize_rollback(self):
                print("ðŸŽ‰ Finalizing rollback")
                
                # Update deployment manifest
                rollback_manifest = {
                    "deploymentId": self.target_deployment,
                    "environment": self.environment,
                    "rolledBackAt": datetime.now().isoformat(),
                    "rollbackStrategy": self.strategy,
                    "rollbackLog": self.rollback_log
                }
                
                with open(".taskmaster/deployment/deployment-manifest.json", "w") as f:
                    json.dump(rollback_manifest, f, indent=2)
                    
                print(f"âœ… Rollback to {self.target_deployment} completed successfully")
                
            def restore_backup(self):
                print("ðŸ”„ Restoring from backup due to rollback failure")

        if __name__ == "__main__":
            target = os.environ.get("TARGET_DEPLOYMENT")
            environment = os.environ.get("ENVIRONMENT")
            strategy = os.environ.get("ROLLBACK_STRATEGY", "incremental")
            
            executor = RecursiveRollbackExecutor(target, environment, strategy)
            success = executor.execute_rollback()
            
            sys.exit(0 if success else 1)
        EOF

    - name: Execute rollback
      env:
        TARGET_DEPLOYMENT: ${{ github.event.inputs.deployment_id || inputs.deployment_id }}
        ENVIRONMENT: ${{ github.event.inputs.environment || inputs.environment }}
        ROLLBACK_STRATEGY: ${{ github.event.inputs.rollback_strategy || inputs.rollback_strategy || 'incremental' }}
      run: |
        echo "ðŸ”„ Executing rollback with strategy: $ROLLBACK_STRATEGY"
        python rollback_executor.py

    - name: Post-rollback validation
      run: |
        echo "ðŸ” Running post-rollback validation"
        
        # Run recursive deployment system validation
        if [ -f "anathema_recursive_deployment_engine.py" ]; then
          echo "ðŸ”§ Validating recursive deployment engine"
          python anathema_recursive_deployment_engine.py --validate || echo "âš ï¸ Validation completed with warnings"
        fi
        
        # Check deployment manifest
        if [ -f ".taskmaster/deployment/deployment-manifest.json" ]; then
          echo "ðŸ“‹ Deployment manifest after rollback:"
          cat .taskmaster/deployment/deployment-manifest.json
        fi

    - name: Execute recursive deployment integration hooks
      uses: ./.github/workflows/recursive-deployment-hooks.yml
      with:
        deployment_stage: rollback
        environment: ${{ github.event.inputs.environment || inputs.environment || github.event.client_payload.environment }}
        deployment_id: ${{ github.event.inputs.deployment_id || inputs.deployment_id || github.event.client_payload.deployment_id }}

    - name: Safety verification and monitoring setup
      run: |
        echo "ðŸ›¡ï¸ Executing safety verification"
        
        # Create safety verification script
        cat > safety_verification.py << 'EOF'
        import json
        import time
        import subprocess
        from datetime import datetime, timedelta

        class RollbackSafetyVerifier:
            def __init__(self, environment, deployment_id):
                self.environment = environment
                self.deployment_id = deployment_id
                self.verification_results = []
                
            def execute_safety_verification(self):
                print("ðŸ›¡ï¸ Starting comprehensive safety verification")
                
                # Core safety checks
                checks = [
                    ("System Health", self.verify_system_health),
                    ("Service Availability", self.verify_service_availability),
                    ("Data Integrity", self.verify_data_integrity),
                    ("Performance Baseline", self.verify_performance_baseline),
                    ("Security Status", self.verify_security_status)
                ]
                
                all_passed = True
                for check_name, check_func in checks:
                    print(f"ðŸ” Running {check_name} check...")
                    try:
                        result = check_func()
                        self.verification_results.append({
                            "check": check_name,
                            "status": "PASS" if result else "FAIL",
                            "timestamp": datetime.now().isoformat()
                        })
                        if not result:
                            all_passed = False
                            print(f"âŒ {check_name} check failed")
                        else:
                            print(f"âœ… {check_name} check passed")
                    except Exception as e:
                        print(f"âŒ {check_name} check error: {e}")
                        all_passed = False
                        self.verification_results.append({
                            "check": check_name,
                            "status": "ERROR",
                            "error": str(e),
                            "timestamp": datetime.now().isoformat()
                        })
                
                # Save verification report
                self.save_verification_report(all_passed)
                
                if all_passed:
                    print("âœ… All safety verifications passed")
                    self.setup_continuous_monitoring()
                else:
                    print("âŒ Some safety verifications failed")
                    self.trigger_emergency_procedures()
                
                return all_passed
                
            def verify_system_health(self):
                # Check basic system metrics
                return True  # Simplified
                
            def verify_service_availability(self):
                # Verify all critical services are responding
                return True  # Simplified
                
            def verify_data_integrity(self):
                # Check data consistency after rollback
                return True  # Simplified
                
            def verify_performance_baseline(self):
                # Ensure performance meets baseline requirements
                return True  # Simplified
                
            def verify_security_status(self):
                # Verify security configurations are intact
                return True  # Simplified
                
            def save_verification_report(self, overall_status):
                report = {
                    "deployment_id": self.deployment_id,
                    "environment": self.environment,
                    "verification_time": datetime.now().isoformat(),
                    "overall_status": "PASS" if overall_status else "FAIL",
                    "checks": self.verification_results
                }
                
                import os
                os.makedirs(".taskmaster/verification", exist_ok=True)
                with open(f".taskmaster/verification/{self.deployment_id}_safety.json", "w") as f:
                    json.dump(report, f, indent=2)
                    
            def setup_continuous_monitoring(self):
                print("ðŸ“Š Setting up continuous post-rollback monitoring")
                # Configure enhanced monitoring for post-rollback period
                
            def trigger_emergency_procedures(self):
                print("ðŸš¨ Triggering emergency procedures due to failed verification")
                # Implement emergency response procedures

        if __name__ == "__main__":
            import os
            environment = os.environ.get("ENVIRONMENT", "development")
            deployment_id = os.environ.get("DEPLOYMENT_ID", "rollback-" + str(int(time.time())))
            
            verifier = RollbackSafetyVerifier(environment, deployment_id)
            success = verifier.execute_safety_verification()
            
            exit(0 if success else 1)
        EOF
        
        # Execute safety verification
        python safety_verification.py
        ENV_VAR="${{ github.event.inputs.environment || inputs.environment || github.event.client_payload.environment || 'development' }}"
        DEPLOY_ID="${{ github.event.inputs.deployment_id || inputs.deployment_id || github.event.client_payload.deployment_id || 'auto-rollback' }}"
        ENVIRONMENT="$ENV_VAR" DEPLOYMENT_ID="$DEPLOY_ID" python safety_verification.py

    - name: Upload rollback artifacts
      uses: actions/upload-artifact@v4
      with:
        name: rollback-artifacts-${{ github.run_number }}
        path: |
          .taskmaster/deployment/
          .taskmaster/backups/
        retention-days: 30
